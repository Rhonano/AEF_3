library(tidyverse)
library(tidyquant)

ticker <- tq_index("DOW") 

prices <- tq_get(ticker %>% 
                   filter(ticker!="DOW"), get = "stock.prices")
returns <- prices %>% 
  group_by(symbol) %>% 
  mutate(log_price = log(adjusted),
         return = 100 * (log_price - lag(log_price))) %>%   
  select(ticker = symbol, date, return) %>%
  na.omit() %>% 
  mutate(return = return - mean(return))

library(slider)

rolling_sd <- returns %>% 
  group_by(ticker) %>% 
  mutate(rolling_sd = slide_dbl(return, sd, 
                                .before = 100)) # 100 day estimation window

rolling_sd %>% 
  ggplot(aes(x=date, y = rolling_sd, color = ticker)) + 
  geom_line() +
  labs(x = "", y = "Standard deviation (rolling window") +
  theme(legend.position = "bottom")

ret <- returns %>% 
  filter(ticker =="AAPL") %>% 
  pull(return)

logL <- function(params, p){
  eps_sqr_lagged <- cbind(ret, 1)
  for(i in 1:p){
    eps_sqr_lagged <- cbind(eps_sqr_lagged, lag(ret, i)^2)
  }
  eps_sqr_lagged <- na.omit(eps_sqr_lagged)
  sigma <- eps_sqr_lagged[,-1] %*% params
  0.5 * sum(log(sigma)) + 0.5 * sum(eps_sqr_lagged[,1]^2/sigma)
}
p <- 2
initial_params <- (c(sd(ret), rep(1, p)))
fit_manual <- optim(par = initial_params, 
                    fn = logL, 
                    hessian = TRUE, 
                    method="L-BFGS-B", 
                    lower = 0, 
                    p = p)

fitted_params <- (fit_manual$par)
se <- sqrt(diag(solve(fit_manual$hessian)))

cbind(fitted_params, se) %>% knitr::kable(digits = 2)
cbind(fitted_params, se)

library(tseries)
summary(garch(ret,c(0,p)))

# GARCH 

garch_logL <- function(params, p, q, return_only_loglik = TRUE){
  eps_sqr_lagged <- cbind(ret, 1)
  for(i in 1:p){
    eps_sqr_lagged <- cbind(eps_sqr_lagged, lag(ret, i)^2)
  }
  sigma.sqrd <- rep(sd(ret)^2, nrow(eps_sqr_lagged))
  for(t in (1 + max(p, q)):nrow(eps_sqr_lagged)){
    sigma.sqrd[t] <- params[1:(1+p)]%*% eps_sqr_lagged[t,-1] + 
      params[(2+p):length(params)] %*% sigma.sqrd[(t-1):(t-q)]
  }
  sigma.sqrd <- sigma.sqrd[-(1:(max(p, q)))]
  
  if(return_only_loglik){
    0.5 * sum(log(sigma.sqrd)) + 0.5 * sum(eps_sqr_lagged[(1 + max(p, q)):nrow(eps_sqr_lagged),1]^2/sigma.sqrd)
  }else{
    return(sigma.sqrd)
  }
}

p <- 1 # Lag structure 
q <- 1 
fit_garch_manual <- optim(par = rep(0.01, p + q + 1), 
                          fn = garch_logL, 
                          hessian = TRUE, 
                          method="L-BFGS-B", 
                          lower = 0, 
                          p = p,
                          q = q)

fitted_garch_params <- fit_garch_manual$par
fitted_garch_params

tibble(vola = garch_logL(fitted_garch_params, p, q, FALSE)) %>% 
  ggplot(aes(x = 1:length(vola), y = sqrt(vola))) +
  geom_line() +
  labs(x = "", y  = "GARCH(1,1) variance")

# Estimate ARCH(1) for all ticker
uncond_var <- returns %>% 
  arrange(ticker, date) %>% 
  nest(data = c(date, return)) %>% 
  mutate(arch = map(data, function(.x){
    logL <- function(params, p){
      eps_sqr_lagged <- cbind(ret, 1)
      for(i in 1:p){
        eps_sqr_lagged <- cbind(eps_sqr_lagged, lag(ret, i)^2)
      }
      eps_sqr_lagged <- na.omit(eps_sqr_lagged)
      sigma <- eps_sqr_lagged[,-1] %*% params
      0.5 * sum(log(sigma)) + 0.5 * sum(eps_sqr_lagged[,1]^2/sigma)
    }
    
    ret <- .x %>% pull(return)    
    p <- 2
    initial_params <- (c(sd(ret), rep(1, p)))
    fit_manual <- optim(par = initial_params, 
                        fn = logL, 
                        hessian = TRUE, 
                        method="L-BFGS-B", 
                        lower = 0, 
                        p = p)
    
    fitted_params <- (fit_manual$par)
    se <- sqrt(diag(solve(fit_manual$hessian)))
    
    return(tibble(param = c("intercept", paste0("alpha ", 1:p)), value = fitted_params, se = se))
  })) %>% 
  select(-data) %>% 
  unnest(arch) %>%
  group_by(ticker) %>% 
  summarise(uncond_var = first(value) / (1 - sum(value) + first(value)))

uncond_var %>% 
  ggplot() + 
  geom_bar(aes(x = reorder(ticker, uncond_var), 
               y = uncond_var), stat = "identity") + 
  coord_flip() +
  labs(x = "Unconditional Variance", 
       y = "")

